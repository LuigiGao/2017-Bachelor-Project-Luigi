import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;

/**
 * A topology which prosumers are nodes, and connections between two prosumers are links
 * 
 * @author Luigi
 *
 */
public class Topology {

	// matrix representation for a matrix M:
	// prosumer/prosumer  0 1
	//                0 [ x x ]
	//                1 [ x x ]

	// M[x][y] = -1 means no connection between prosumer x and prosumer y, otherwise a connection between x and y
	// M[x][y] = 0 means there is no electric energy from x to y
	// M[x][y] > 0 means there is electric energy from x to y
	/** A map of energy flow among all prosumers */
	private double[][] topology_Status;
	
	// if M[x][y] >= 0, M[x][y] is the max load between prosumer x and prosumer y
	/** A map of max load among all prosumers */
	private double[][] max_loads;
	
	// M[x][y] = -1 means no connection between prosumer x and prosumer y
	// M[x][y] >= 0 means there is connection between prosumer x and prosumer y which Resistance is value stored in M[x][y]
	/** A map of connection among all prosumers */
	private double[][] connections;
	
	// index of prosumer in array is also the index of row and column in matrix which is stored as id in prosumer
	private ArrayList<Prosumer> prosumers;
	private int prosumer_ID;
	
	/**
	 *  a map between house number and id.
	 *  house number is given as a input when add a prosumer.
	 *  id is generated by program automatically.
	 */
	private HashMap<Integer, Integer> houseNumber_id;
	
	// electric utility is located at one of prosumer's place which represent by id of that prosumer
	/** electric_Utility is represented by id of one prosumer, which sell/buy energy to/from prosumer */
	private int electric_Utility;
	
	/** provide information of weather */
	private WeatherSimulator weather;
	
	/**
	 * Build a topology which prosumers are nodes, and connections between two prosumers are links
	 * 
	 * @param prosumer_info path of a file that contain information of all prosumers
	 * @param relation_info path of a file that contain resistance, max load information among all prosumers
	 */
	public Topology( String prosumer_info, String relation_info ) {
		
		this.houseNumber_id = new HashMap<Integer, Integer>( );
		this.prosumer_ID = 0;
		parseProsumers( prosumer_info );
		initialMatrix();
		parseRelation( relation_info );
		
	}
	
	/** Initial the matrix that use for store information of connection, max load, and energy flow */
	private void initialMatrix( ) {
		
		this.topology_Status = new double[prosumers.size()][prosumers.size()];
		this.max_loads = new double[prosumers.size()][prosumers.size()];
		this.connections = new double[prosumers.size()][prosumers.size()];
		int nProsumer = this.prosumers.size();
		
		for( int i = 0; i < nProsumer; i++ ) {
			for( int j = 0; j < nProsumer; j++ ) {
				this.topology_Status[i][j] = -1;
				this.max_loads[i][j] = -1;
				this.connections[i][j] = -1;
			}
		}
		
	}
	
	private void addProsumer( int houseNumber ) {
		this.prosumers.add( new Prosumer( this.prosumer_ID, houseNumber ) );
		this.prosumer_ID++;
	}
	
	private void addRelation( int houseA, int houseB, int maxLoad, int resistance ) {
		
		this.max_loads[houseA][houseB] = maxLoad;
		this.max_loads[houseB][houseA] = maxLoad;
		this.connections[houseA][houseB] = resistance;
		this.connections[houseB][houseA] = resistance;
		
	}
	
	/**
	 * Build nodes of the topology
	 * 
	 * @param file path of a file that contain information of all prosumers
	 */
	private void parseProsumers( String file ) {
		
		JSONParser parser = new JSONParser();
		Object prosumers_info;
		
		try {
			prosumers_info = parser.parse( new FileReader( file ) );
			JSONArray prosumers = (JSONArray)prosumers_info;
			
			Iterator<JSONObject> iterator = prosumers.iterator();
			while (iterator.hasNext()) {
				JSONObject prosumer = iterator.next();
				parseProsumer( prosumer );
            }
			
		} catch (IOException | ParseException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	/**
	 * Add one prosumer to topology's nodes
	 * 
	 * @param obj information of one prosumer
	 */
	private void parseProsumer( JSONObject obj ) {
		
		int houseNumber = Integer.parseInt( (String) obj.get("houseNumber"));
		this.houseNumber_id.put( houseNumber, this.prosumer_ID);
		
		Prosumer prosumer = new Prosumer( this.prosumer_ID, houseNumber );
		this.prosumers.add( prosumer );
		this.prosumer_ID++;
		
		parseWindTurbine( prosumer, (JSONArray)obj.get("windTurbines") );
		parsePhotovoltaicPanel( prosumer, (JSONArray)obj.get("photovoltaicPanels") );
		
	}
	
	/**
	 * Add wind turbines to a prosumer
	 * 
	 * @param prosumer a house that both consume and produce energy
	 * @param windTurbines a array of wind turbine's information
	 */
	private void parseWindTurbine( Prosumer prosumer, JSONArray windTurbines ) {
		
		Iterator<JSONObject> iterator = windTurbines.iterator();
		while (iterator.hasNext()) {
			JSONObject windTurbine = iterator.next();
			double bladeLength = Double.parseDouble( (String) windTurbine.get("bladeLength") );
			double maxPowerOutput = Double.parseDouble( (String) windTurbine.get("maxPowerOutput") );
			prosumer.addWindTurbine( new WindTurbine( bladeLength, maxPowerOutput ) );
        }
		
	}
	
	/**
	 * Add photovoltaic panels to a prosumer
	 * 
	 * @param prosumer a house that both consume and produce energy
	 * @param photovoltaicPanels a array of photovoltaic panel's information
	 */
	private void parsePhotovoltaicPanel( Prosumer prosumer, JSONArray photovoltaicPanels ) {
		
		Iterator<JSONObject> iterator = photovoltaicPanels.iterator();
		while (iterator.hasNext()) {
			JSONObject windTurbine = iterator.next();
			double panelArea = Double.parseDouble( (String) windTurbine.get("panelArea") );
			double maxPowerOutput = Double.parseDouble( (String) windTurbine.get("maxPowerOutput") );
			prosumer.addPhotovoltaicPanel( new PhotovoltaicPanel( panelArea, maxPowerOutput ) );
        }
		
	}
	
	/**
	 * Build a connection topology among all houses
	 * 
	 * @param file path of a file that contain resistance, max load information among all prosumers
	 */
	private void parseRelation( String file ) {
		
		JSONParser parser = new JSONParser();
		Object relation_info;
		
		try {
			relation_info = parser.parse( new FileReader( file ) );
			JSONObject relation = (JSONObject)relation_info;

			JSONArray connections = (JSONArray)relation.get("connections");
			Iterator<JSONObject> iterator = connections.iterator();
			while ( iterator.hasNext() ) {
				JSONObject connection = iterator.next();
				parseConnection( connection );
            }
			
			// parse electric utility
			this.electric_Utility = this.houseNumber_id.get( Integer.parseInt( (String) relation.get("electric_Utility") ) );
			
		} catch (IOException | ParseException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	/**
	 * Add a connection between two prosumers
	 * 
	 * @param connection information of resistance, max load between two prosumers
	 */
	private void parseConnection( JSONObject connection ) {

		int houseNumber1 = this.houseNumber_id.get( Integer.parseInt( (String) connection.get("houseNumber1")) );
		int houseNumber2 = this.houseNumber_id.get( Integer.parseInt( (String) connection.get("houseNumber2")) );
		double resistance = Double.parseDouble( (String) connection.get("resistance"));
		double maxLoad = Double.parseDouble( (String) connection.get("max_load"));
		
		this.max_loads[houseNumber1][houseNumber2] = maxLoad;
		this.max_loads[houseNumber2][houseNumber1] = maxLoad;
		this.connections[houseNumber1][houseNumber2] = resistance;
		this.connections[houseNumber2][houseNumber1] = resistance;
		
	}
	
}
