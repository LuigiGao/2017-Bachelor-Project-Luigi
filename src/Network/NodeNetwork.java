package Network;

import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;

import Algorithm.DijkstraAlgorithm;
import EnergyGenerator.PhotovoltaicPanel;
import EnergyGenerator.WindTurbine;
import Parser.TopologyJsonParser;
import Plan.Flow;
import Plan.Flows;
import Plan.PlanBalanceCostEnergyLoss;
import Plan.PlanMinEnergyLoss;
import Weather.Weather;
import Weather.WeatherDatabase;

/**
 * A topology which prosumers are nodes, and connections between two prosumers
 * are links
 * 
 * @author Luigi
 *
 */
public class NodeNetwork implements Runnable {

	// index of prosumer in array is also the index of row and column in matrix
	// which is stored as id in prosumer
	/** A array of prosumers */
	private ArrayList<Prosumer> prosumers;

	// +/- number means sell/buy
	/** Energy to sell/buy for all prosumers at a particular hour */
	private double[] prosumers_energy;

	/** Price of each prosumer at a particular hour */
	private double[] prosumers_price;

	private double[] resistance_form_EU;

	/**
	 * A map between house number and id. house number is given as a input when add
	 * a prosumer. id is generated by program automatically.
	 */
	private HashMap<Integer, Integer> houseNumber_id;

	// electric utility is located at one of prosumer's place which represent by id
	// of that prosumer
	/**
	 * Electric_Utility is represented by id of one prosumer, which sell/buy energy
	 * to/from prosumer
	 */
	private int electric_Utility;

	/** Price of buying electricity from electric utility */
	private double priceEU_sell;

	/** Price of selling electricity to electric utility */
	private double priceEU_buy;

	/** Provide information of weather */
	private WeatherDatabase weather_database;

	/** Parse the information file */
	private TopologyJsonParser parser;

	/** Voltage of the network (in 1V) */
	private double voltage;

	/** Interval of time (in 1h) */
	private double time_interval;

	/** Number of remaining simulation days */
	private int remaining_day;

	/** Plan that manage the energy flow between prosumers */
	private PlanBalanceCostEnergyLoss planBalance;
	private PlanMinEnergyLoss planMinEnergyLoss;

	// matrix representation for a matrix M:
	// prosumer/prosumer 0 1
	// 0 [ x x ]
	// 1 [ x x ]

	// M[x][y] = 0 means there is no electric energy from x to y
	// M[x][y] > 0 means there is electric energy from x to y
	/** A map of energy flow among all prosumers */
	private double[][] loads_status;

	// if M[x][y] >= 0, M[x][y] is the max load between prosumer x and prosumer y
	/** A map of max load among all prosumers */
	private double[][] max_loads;

	// M[x][y] = -1 means no connection between prosumer x and prosumer y
	// M[x][y] >= 0 means there is connection between prosumer x and prosumer y
	// which Resistance is value stored in M[x][y]
	/** A map of connection among all prosumers */
	private double[][] connections;

	// Following matrix are used to store some data to analysis
	/**
	 * Total cost for each prosumer for buying energy from other prosumers or
	 * electic utility
	 */
	private double[] prosumers_cost;

	/**
	 * Total profit for each prosumer for selling energy from other prosumers or
	 * electic utility
	 */
	private double[] prosumers_profit;

	/** Energy bought for each prosumer */
	private double[] prosumers_energy_buy;

	/** Energy selled for each prosumer */
	private double[] prosumers_energy_sell;

	/** Sum of all energy transmit for all prosumers */
	private double total_energy_transmit;

	/** Sum of all energy loss for all prosumers */
	private double total_energy_loss;

	/**
	 * Build a topology which prosumers are nodes, and connections between two
	 * prosumers are links
	 * 
	 * @param prosumer_info
	 *            path of a file that contain information of all prosumers
	 * @param relation_info
	 *            path of a file that contain resistance, max load information among
	 *            all prosumers
	 */
	public NodeNetwork(String prosumer_info, String relation_info) {

		initialBefore(prosumer_info, relation_info);
		parser.parseProsumers();
		initialAfter();
		parser.parseRelations();
		buildResistanceEU();

	}

	/**
	 * 
	 * @param prosumer_info
	 * @param relation_info
	 * @param weather_info
	 *            path of a file that contain weather information
	 */
	public NodeNetwork(String prosumer_info, String relation_info, String weather_info) {

		this(prosumer_info, relation_info);

		weather_database = new WeatherDatabase(weather_info);

	}

	/**
	 * 
	 * @param prosumer_info
	 * @param relation_info
	 * @param weather_info
	 * @param remaining_day
	 *            simulation days
	 */
	public NodeNetwork(String prosumer_info, String relation_info, String weather_info, int remaining_day) {

		this(prosumer_info, relation_info, weather_info);

		this.remaining_day = remaining_day;

	}

	/**
	 * initial variables
	 * 
	 * @param prosumer_info
	 * @param relation_info
	 */
	private void initialBefore(String prosumer_info, String relation_info) {
		this.parser = new TopologyJsonParser(this, prosumer_info, relation_info);

		this.prosumers = new ArrayList<Prosumer>();
		this.houseNumber_id = new HashMap<Integer, Integer>();
		this.voltage = 220;
		this.time_interval = 1;

		this.electric_Utility = 0;
		// 2017 electricity price (per kWh) in Netherlands
		// From
		// http://ec.europa.eu/eurostat/statistics-explained/index.php/Electricity_price_statistics
		this.priceEU_sell = 0.082;
		this.priceEU_buy = 0.041;
	}

	/**
	 * initial the matrix that use for store information of connection, max load,
	 * energy flow, etc...
	 */
	private void initialAfter() {

		this.planBalance = new PlanBalanceCostEnergyLoss(this);
		this.planMinEnergyLoss = new PlanMinEnergyLoss(this);

		// for simulation
		this.loads_status = new double[prosumers.size()][prosumers.size()];
		this.max_loads = new double[prosumers.size()][prosumers.size()];
		this.connections = new double[prosumers.size()][prosumers.size()];
		this.prosumers_energy = new double[prosumers.size()];
		this.prosumers_price = new double[prosumers.size()];
		this.resistance_form_EU = new double[prosumers.size()];

		// for analysis the difference between different topology, plan, algorithm
		this.prosumers_cost = new double[prosumers.size()];
		this.prosumers_profit = new double[prosumers.size()];
		this.prosumers_energy_buy = new double[prosumers.size()];
		this.prosumers_energy_sell = new double[prosumers.size()];
		this.total_energy_transmit = 0;
		this.total_energy_loss = 0;

		int nProsumer = this.prosumers.size();

		for (int i = 0; i < nProsumer; i++) {
			for (int j = 0; j < nProsumer; j++) {
				this.loads_status[i][j] = 0;
				this.max_loads[i][j] = -1;
				this.connections[i][j] = -1;
			}
			this.prosumers_energy[i] = 0;
			this.prosumers_price[i] = 0;
			this.resistance_form_EU[i] = 0;
			this.prosumers_cost[i] = 0;
			this.prosumers_profit[i] = 0;
			this.prosumers_energy_buy[i] = 0;
			this.prosumers_energy_sell[i] = 0;
		}

	}

	/**
	 * Build a array that contains resistance from electric utility to all prosumers
	 */
	private void buildResistanceEU() {
		DijkstraAlgorithm algorithm = new DijkstraAlgorithm(this);
		for (int i = 0; i < this.prosumers.size(); i++) {
			ArrayList<Integer> path_to_EU = algorithm.findPath(i, this.electric_Utility);
			if (path_to_EU.size() < 2) {
				this.resistance_form_EU[i] = 0;
			} else {
				double resistance = this.getResistance(path_to_EU);
				this.resistance_form_EU[i] = resistance;
			}
		}
	}

	/**
	 * Add one prosumer to network
	 * 
	 * @param prosumer
	 */
	public void addProsumer(Prosumer prosumer) {
		this.prosumers.add(prosumer);
	}

	/**
	 * Set up electric utility
	 * 
	 * @param houseNumber
	 */
	public void setElectricUtility(int houseNumber) {
		this.electric_Utility = this.houseNumber_id.get(houseNumber);
	}

	/**
	 * Add max load and resistance between two prosumers
	 * 
	 * @param houseA
	 * @param houseB
	 * @param maxLoad
	 * @param resistance
	 */
	public void addConnection(int houseA, int houseB, double maxLoad, double resistance) {

		this.max_loads[houseA][houseB] = maxLoad;
		this.max_loads[houseB][houseA] = maxLoad;
		this.connections[houseA][houseB] = resistance;
		this.connections[houseB][houseA] = resistance;

	}

	/**
	 * Add cost to one prosumer
	 * 
	 * @param prosumer
	 * @param cost
	 */
	public void addCost(int prosumer, double cost) {
		this.prosumers_cost[prosumer] = this.prosumers_cost[prosumer] + cost;
	}

	/**
	 * Hash the id with prosumer's house number
	 * 
	 * @param houseNumber
	 * @param prosumer_ID
	 */
	public void hashHouseId(int houseNumber, int prosumer_ID) {
		this.houseNumber_id.put(houseNumber, prosumer_ID);
	}

	/**
	 * 
	 * @param houseNumber
	 * @return The id of prosumer with given house number
	 */
	public int getId(int houseNumber) {
		return this.houseNumber_id.get(houseNumber);
	}

	/**
	 * 
	 * @return Number of prosuemrs in this network
	 */
	public int getNumberOfProsumers() {
		// System.out.println( "Prosumer size: " + this.prosumers.size() );
		return this.prosumers.size();
	}

	/**
	 * 
	 * @return Voltage of this network in 1V
	 */
	public double getVoltage() {
		return this.voltage;
	}

	/**
	 * 
	 * @return Interval of time for simulation in 1h
	 */
	public double getTimeInterval() {
		return this.time_interval;
	}

	/**
	 * 
	 * @param provider
	 * @return Net energy of the provider at one interval time
	 */
	public double getProsumerEnergy(int provider) {
		return this.prosumers_energy[provider];
	}

	/**
	 * 
	 * @param provider
	 * @return Price of the provider at one interval time
	 */
	public double getProsumerPrice(int provider) {
		// return the price of enegry for the provider at a particular time slot
		return this.prosumers_price[provider];
	}

	/**
	 * 
	 * @return Price when buying energy from electric utility
	 */
	public double getSellPriceEU() {
		return this.priceEU_sell;
	}

	/**
	 * 
	 * @return Price when selling energy to electric utility
	 */
	public double getBuyPriceEU() {
		return this.priceEU_buy;
	}

	/**
	 * 
	 * @return Id that represents electric utility
	 */
	public int getElecticUtility() {
		return this.electric_Utility;
	}

	/**
	 * 
	 * @param prosumerA
	 * @param prosumerB
	 * @return The resistance between prosumerA and prosumerB
	 */
	public double getConnection(int prosumerA, int prosumerB) {
		return this.connections[prosumerA][prosumerB];
	}

	/**
	 * 
	 * @param prosumerA
	 * @param prosumerB
	 * @return The current loads between prosumerA and prosumerB
	 */
	public double getCurrentLoad(int prosumerA, int prosumerB) {
		return this.loads_status[prosumerA][prosumerB];
	}

	/**
	 * 
	 * @param prosumerA
	 * @param prosumerB
	 * @return The maximum load between prosumerA and prosumerB
	 */
	public double getMaxLoad(int prosumerA, int prosumerB) {
		return this.max_loads[prosumerA][prosumerB];
	}

	/**
	 * 
	 * @return A array of prosumers that need to buy energy
	 */
	public ArrayList<Integer> getConsumers() {
		ArrayList<Integer> consumers = new ArrayList<Integer>();
		for (int i = 0; i < this.prosumers_energy.length; i++) {
			if (this.prosumers_energy[i] < 0) {
				consumers.add(i);
			}
		}
		return consumers;
	}

	/**
	 *
	 * @return A array of prosumers that need to sell energy
	 */
	public ArrayList<Integer> getProviders() {
		ArrayList<Integer> sellers = new ArrayList<Integer>();
		for (int i = 0; i < this.prosumers_energy.length; i++) {
			if (this.prosumers_energy[i] > 0) {
				sellers.add(i);
			}
		}
		return sellers;
	}

	/**
	 * 
	 * @param source
	 * @return A array of resistances from one prosumer to all other prosumers
	 */
	public double[] getResistances(int source) {
		int n = this.prosumers.size();
		double[] connection = new double[n];
		for (int i = 0; i < n; i++) {
			connection[i] = this.connections[source][i];
		}
		return connection;
	}

	/**
	 * 
	 * @param prosumerA
	 * @param prosumerB
	 * @return The resistance between prosumerA and prosumerB
	 */
	public double getResistance(int prosumerA, int prosumerB) {
		// System.out.println( "i is " + i );
		// System.out.println( "j is " + j );
		// System.out.println( "size is " + this.prosumers.size() );
		if (prosumerA < 0 || prosumerA >= this.prosumers.size() || prosumerB < 0
				|| prosumerB >= this.prosumers.size()) {
			System.out.println("Error: Invalid house id");
			return -1;
		}
		// System.out.println( "Resistance is " + this.connections[i][j] );
		return this.connections[prosumerA][prosumerB];
	}

	/**
	 * 
	 * @param path
	 * @return The sum of all resistance between two prosumers in the path
	 */
	public double getResistance(ArrayList<Integer> path) {

		int index = 0;
		double resistance = 0;

		int prosumerA = path.get(index);
		index++;
		// System.out.println( "ProsumerA: " + prosumerA );
		int prosumerB;

		while (index < path.size()) {
			prosumerB = path.get(index);
			// System.out.println( "ProsumerB: " + prosumerB );
			resistance = resistance + getResistance(prosumerA, prosumerB);
			prosumerA = prosumerB;
			index++;
		}
		return resistance;

	}

	/**
	 * Check the connection, energy flow and max load between the given consumer
	 * with all prosumers
	 * 
	 * @param prosumer
	 * @return A array of providers that can sell energy to the given consumer
	 */
	public ArrayList<Integer> getNeighbours(int prosumer) {
		ArrayList<Integer> neighbours = new ArrayList<Integer>();
		int n = this.prosumers.size();
		for (int i = 0; i < n; i++) {
			// three assumption to check the neighbours
			// 1. there is connection between house_id and i
			// 2. there is no energy flow form i to house_id
			// 3. the energy flow from house_id to i is smaller than the max load between
			// them
			if (this.connections[prosumer][i] >= 0 && this.loads_status[i][prosumer] == 0
					&& this.loads_status[prosumer][i] < this.max_loads[prosumer][i]) {
				neighbours.add(i);
			}
		}
		return neighbours;
	}

	public ArrayList<Integer> getNeighbours(int prosumer, double[][] temp_loads) {
		ArrayList<Integer> neighbours = new ArrayList<Integer>();
		int n = this.prosumers.size();
		for (int i = 0; i < n; i++) {
			if (this.connections[prosumer][i] >= 0 && temp_loads[i][prosumer] == 0
					&& temp_loads[prosumer][i] < this.max_loads[prosumer][i]) {
				neighbours.add(i);
			}
		}
		return neighbours;
	}

	/**
	 * Check capacity between pairs of two prosumers in the path, and the energy of
	 * the source. Take the minimum as the capacity of the path.
	 * 
	 * @param path
	 * @return The capacity of the path
	 */
	public double getCapacity(ArrayList<Integer> path) {

		double min_capacity = Double.MAX_VALUE;
		int source = path.get(0);

		int index = 0;
		int prosumerA = path.get(index);
		index++;
		int prosumerB;

		while (index < path.size()) {
			prosumerB = path.get(index);

			if (this.loads_status[prosumerB][prosumerA] == 0) {
				double capacityAB = this.max_loads[prosumerA][prosumerB] - this.loads_status[prosumerA][prosumerB];
				if (capacityAB < min_capacity) {
					min_capacity = capacityAB;
				}
			} else {
				return 0;
			}

			prosumerA = prosumerB;
			index++;
		}
		// System.out.println("Capacity is " + min_capacity);
		// System.out.println("Source Energy is " + this.prosumers_energy[source]);
		return Math.min(min_capacity, this.prosumers_energy[source]);

	}

	/**
	 * 
	 * @return A copy of load status between all prosumers
	 */
	public double[][] copyLoadsStatus() {
		double[][] copy = new double[this.prosumers.size()][this.prosumers.size()];
		for (int i = 0; i < this.prosumers.size(); i++) {
			for (int j = 0; j < this.prosumers.size(); j++) {
				copy[i][j] = this.loads_status[i][j];
			}
		}
		return copy;
	}

	/**
	 * 
	 * @return A copy of prosumer current energy
	 */
	public double[] copyCurrentEnergy() {
		double[] copy = new double[this.prosumers.size()];
		for (int i = 0; i < this.prosumers.size(); i++) {
			copy[i] = this.prosumers_energy[i];
		}
		return copy;
	}

	/**
	 * Print all information(house number, wind turbines, photovoltaic panels) of
	 * prosumers, and their relationship
	 */
	public void printNodeInfo() {
		for (Prosumer prosumer : this.prosumers) {
			System.out.println(prosumer.info());
		}
		int n = prosumers.size();
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < i; j++) {
				if (this.connections[i][j] >= 0) {
					System.out.println("Connection between " + prosumers.get(i).getHouseNumber() + " and "
							+ prosumers.get(j).getHouseNumber() + ": " + this.connections[i][j] + "R, "
							+ this.max_loads[i][j] + "J");
				}
			}
		}
	}

	/**
	 * Print the given matrix
	 * 
	 * @param matrix
	 */
	private void printMatrix(double[][] matrix) {

		int n = this.prosumers.size();
		String line;
		String number = "";

		int digits = 0;
		while (n != 0) {
			digits++;
			n = n / 10;
		}

		if (digits == 0) {
			System.out.println("Error: no valid prosumer");
		} else if (digits > 3) {
			System.out.println("Information: too much prosumers");
		}

		// first index row
		line = "   ";
		for (int i = 0; i < this.prosumers.size(); i++) {
			if (i < 10) {
				line = line + "    " + i;
			} else {
				line = line + "   " + i;
			}
		}
		System.out.println(line);

		// print the matrix
		for (int i = 0; i < this.prosumers.size(); i++) {
			// add index column
			if (i < 10) {
				line = " " + i + " ";
			} else {
				line = "" + i + " ";
			}
			// add matrix value with fix size (max 4 digit)
			for (int j = 0; j < this.prosumers.size(); j++) {

				number = "" + matrix[i][j];
				if (number.length() > 5) {
					number = number.substring(0, 4);
				}
				while (number.length() < 5) {
					number = " " + number;
				}

				// add matrix value
				line = line + number;
			}
			System.out.println(line);
		}
	}

	/**
	 * Print maximum load between all prosumers as a matrix
	 */
	public void printMaxLoad() {
		System.out.println("Max Load");
		printMatrix(this.max_loads);
	}

	/**
	 * Print resistance between all prosumers as a matrix
	 */
	public void printConnection() {
		System.out.println("Connection");
		printMatrix(this.connections);
	}

	/**
	 * Print load(energy) status between all prosumers as a matrix
	 */
	public void printLoadsStatus() {
		System.out.println("Energy flows");
		printMatrix(this.loads_status);
	}

	/**
	 * Update a path with energy. For each pairs of prosumers, add energy to load
	 * status. For the seller, subtract the energy to current energy storage.
	 * 
	 * @param path
	 * @param energy
	 * @param resistance 
	 */
	public void updateEnergyFlow(ArrayList<Integer> path, double energy, double resistance) {

		// update conclusion
		int provider = path.get(0);
		int consumer = path.get(path.size() - 1);
		double loss = ( energy * energy * resistance ) / ( this.time_interval * this.voltage * this.voltage );
		this.prosumers_energy_sell[ provider ] += energy;
		this.prosumers_energy_buy[ consumer ] += energy;
		this.prosumers_profit[ provider ] += energy * this.prosumers_price[provider];
		this.prosumers_cost[ consumer ] += energy * this.prosumers_price[provider];
		this.total_energy_transmit += energy;
		this.total_energy_loss += loss;
		
		// update status of network
		
		int index = 0;
		int prosumerA;
		int prosumerB;

		prosumerA = path.get(index);
		// prosumerA sell energy
		this.prosumers_energy[prosumerA] = this.prosumers_energy[prosumerA] - energy;
		index++;

		while (index < path.size()) {
			prosumerB = path.get(index);
			this.loads_status[prosumerA][prosumerB] = this.loads_status[prosumerA][prosumerB] + energy;

			prosumerA = prosumerB;
			index++;
		}
	}

	/**
	 * Subtract all prosumers' current energy with respective energy selled in the
	 * array
	 * 
	 * @param energy_sell
	 */
	public void transferEnergy(double[] energy_sell) {
		for (int i = 0; i < this.prosumers_energy.length; i++) {
			this.prosumers_energy[i] = this.prosumers_energy[i] - energy_sell[i];
		}
	}

	/**
	 * Calculate the energy loss when transfer energy form electric utility to
	 * consumer
	 * 
	 * @param electicUtility
	 * @param consumer
	 * @param energy
	 * @return energy in kWh
	 */
	public double energyLossEU(int consumer, double energy) {
		// energy loss from electric utility to consumer when transfer energy
		// maybe create a private array for store resistance
		return (energy * energy * this.resistance_form_EU[consumer])
				/ (this.time_interval * this.voltage * this.voltage);
	}

	/**
	 * Calculate the capacity of the flow, and simulate energy flow in the network
	 * 
	 * @param flow
	 *            A path which have one source and one destination
	 * @param energy
	 * @return The rest energy cannot transmit through the flow
	 */
	public Double simulateEnergyFlow(Flow flow, double energy) {

		/*
		 * System.out.print("Simulate Flow: "); ArrayList path = flow.getPath(); for
		 * (int i = 0; i < path.size(); i++) { System.out.print(path.get(i) + " "); }
		 * System.out.println();
		 */

		int source = flow.getSource();
		int dest = flow.getDest();

		double loss = flow.getEnergyLoss(this.voltage, this.time_interval, energy);
		double energy_require = energy + loss;
		double capacity = getCapacity(flow.getPath());

		if (energy_require < capacity) {
			updateEnergyFlow(flow.getPath(), energy_require, flow.getResistance() );
			// System.out.println("Prosumer " + dest + " buy " + energy_require + " energy
			// from prosumer " + source);
			return 0.0;
		}

		updateEnergyFlow(flow.getPath(), capacity, flow.getResistance());
		// System.out.println("Prosumer " + dest + " buy " + capacity + " kWh from
		// prosumer " + source);
		return energy - flow.receivedEnergy(capacity, this.voltage, this.time_interval);
	}

	/**
	 * Simulate the energy transfer in flows one by one.
	 * 
	 * @param flows
	 *            Many flows which have same source and same destination
	 * @param energy
	 *            Energy needed to transfer
	 * @return The rest energy cannot transmit through the flow
	 */
	public Double simulateEnergyFlows(Flows flows, double energy) {
		double rest = energy;
		while (rest > 0 && flows.hasNext()) {
			Flow flow = flows.nextFlow();
			rest = simulateEnergyFlow(flow, rest);
		}
		return rest;
	}

	/**
	 * Add cost of buying energy from electric utility to the prosumer
	 * 
	 * @param prosumer
	 * @param energy
	 */
	public void buyEnergyEU(int prosumer, double energy) {
		if (energy > 0) {
			double cost = 0.0;
			double loss = energyLossEU(prosumer, energy);

			cost = this.priceEU_sell * (energy + loss);

			// update conclusion
			this.prosumers_energy_buy[prosumer] += energy;
			this.prosumers_cost[prosumer] += cost;
			this.total_energy_transmit += energy + loss;
			this.total_energy_loss += loss;

			// System.out.println("Prosumer " + prosumer + " buy " + energy + " kWh energy
			// from electric utility");
		}
	}

	/**
	 * Reset matrix for next simulation
	 */
	private void resetSimulation() {
		for (int i = 0; i < this.prosumers.size(); i++)
			for (int j = 0; j < this.prosumers.size(); j++)
				this.loads_status[i][j] = 0;
	}

	/**
	 * Simulation for one hour. Calculate net energy for each prosumer and manage
	 * the energy flow between them.
	 * 
	 * @param weather
	 * @param hour
	 *            hour in a day
	 */
	private void simulation_hour(Weather weather, int hour) {
		// simulate weather -> renewable energy production -> consumption for each
		// prosumer -> optimising the energy flow

		// System.out.println("At " + hour);

		double wind_speed = weather.windSpeed(); // 0.1m/s
		double solar_radiation = weather.solarRadiation(hour) * this.time_interval / 1; // 1J/cm^2 in given hour
																						// interval
		double air_density = weather.airDensity();

		/*
		 * System.out.println( weather.date() + " at " + hour + " wind speed: " +
		 * wind_speed + " solar radiation: " + solar_radiation); for (Prosumer p :
		 * prosumers) { System.out.println("Prosumer " + p.getID() + " output: " +
		 * p.powerOutput(weather.airDensity(), wind_speed, solar_radiation) +
		 * " Watt(J/s)" + " consumption: " + p.energyConsume(hour) + " Wh(J)"); }
		 */

		// put net energy for each prosumer into prosumers_energy array
		int index;
		for (Prosumer p : this.prosumers) {
			index = p.getID();
			this.prosumers_energy[index] = p.output(air_density, wind_speed, solar_radiation, hour);

			// all energy is bought from electric utility
			// this.prosumers_energy[index] = p.energyConsume(hour);

			this.prosumers_price[index] = p.getCurrentPrice();
		}

		// for each buyer find energy providers ( prosumers or electric utility )
		for (int i = 0; i < this.getNumberOfProsumers(); i++) {
			// maybe sort the buyers from far to close by distance to electric utility or
			// choose randomly
			if (this.prosumers_energy[i] < 0)
				// plan and simulate the energy flow
				this.planBalance.plan(i, -this.prosumers_energy[i]);
				//this.planMinEnergyLoss.plan(i, -this.prosumers_energy[i]);
		}

		// finally sell rest energy to electric utility
		for (int i = 0; i < this.getNumberOfProsumers(); i++) {
			if (this.prosumers_energy[i] > 0) {
				this.prosumers_profit[i] = this.prosumers_profit[i] + this.prosumers_energy[i] * getBuyPriceEU();
				// System.out.println(
				// "Prosumer " + i + " sell " + this.prosumers_energy[i] + " kWh energy to
				// Electric Utility");
			}
		}

		// clear matrix for current status for next simulation
		resetSimulation();

	}

	/**
	 * Simulation for one day
	 */
	public void simulation_day() {
		int hour = 0;
		Weather weather = this.weather_database.nextWeather();
		// weather.info();
		// System.out.println(weather.date() + ":");

		for (; hour < 24; hour++) {

			simulation_hour(weather, hour);

			/*
			 * try { Thread.sleep(3000); } catch (InterruptedException e) { // TODO
			 * Auto-generated catch block e.printStackTrace(); }
			 */
		}
	}

	public static double round(double value, int places) {
		if (places < 0)
			throw new IllegalArgumentException();

		long factor = (long) Math.pow(10, places);
		value = value * factor;
		long tmp = Math.round(value);
		return (double) tmp / factor;
	}

	private void printReport( double[] report ) {
		for (int i = 0; i < this.prosumers.size(); i++) {
			String str = Double.toString(round(report[i], 2));
			while (str.length() < 6)
				str = " " + str;
			System.out.print(" " + str);
		}
	}
	
	private void printReport() {

		System.out.print("Prosumers:   ");
		for (int i = 0; i < this.prosumers.size(); i++) {
			if (i < 10)
				System.out.print(" ");
			System.out.print("     " + i);
		}
		System.out.println();

		System.out.print("Total Cost:  ");
		printReport( this.prosumers_cost );
		System.out.println();

		System.out.print("Total Profit:");
		for (int i = 0; i < this.prosumers.size(); i++) {
			String cost = Double.toString(round(this.prosumers_profit[i], 2));
			while (cost.length() < 6)
				cost = " " + cost;
			System.out.print(" " + cost);
		}
		System.out.println();
		
		System.out.print("Energy Buy:  ");
		printReport( this.prosumers_energy_buy );
		System.out.println();

		System.out.print("Energy Sell: ");
		printReport( this.prosumers_energy_sell );
		System.out.println();

		System.out.println( "Total Energy Transmit: " + this.total_energy_transmit + " kWh");
		System.out.println( "Total Energy Loss: " + this.total_energy_loss + " kWh");
		System.out.println( "Loss Percentage: " + this.total_energy_loss / this.total_energy_transmit * 100 + " %");
	}

	@Override
	public void run() {

		while (this.remaining_day > 0) {
			this.remaining_day--;
			// simulate the consume and produce per day
			simulation_day();
		}

		printReport();

	}

	// test
	public void testSimulation() {

		this.prosumers_energy[0] = 3;
		this.prosumers_energy[1] = -1;
		this.prosumers_energy[2] = 5;

		for (int i = 0; i < this.getNumberOfProsumers(); i++) {
			// simulate the energy flow
			if (this.prosumers_energy[i] < 0)
				this.planBalance.plan(i, -this.prosumers_energy[i]);
		}
	}

}
