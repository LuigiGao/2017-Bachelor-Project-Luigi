package Network;

import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;

import EnergyGenerator.PhotovoltaicPanel;
import EnergyGenerator.WindTurbine;
import Parser.TopologyJsonParser;
import Plan.PlanBalanceCostEnergyLoss;
import Weather.Weather;
import Weather.WeatherDatabase;

/**
 * A topology which prosumers are nodes, and connections between two prosumers
 * are links
 * 
 * @author Luigi
 *
 */
public class NodeNetwork implements Runnable {

	// matrix representation for a matrix M:
	// prosumer/prosumer 0 1
	// 0 [ x x ]
	// 1 [ x x ]

	// M[x][y] = 0 means there is no electric energy from x to y
	// M[x][y] > 0 means there is electric energy from x to y
	/** A map of energy flow among all prosumers */
	private double[][] loads_status;

	// if M[x][y] >= 0, M[x][y] is the max load between prosumer x and prosumer y
	/** A map of max load among all prosumers */
	private double[][] max_loads;

	// M[x][y] = -1 means no connection between prosumer x and prosumer y
	// M[x][y] >= 0 means there is connection between prosumer x and prosumer y
	// which Resistance is value stored in M[x][y]
	/** A map of connection among all prosumers */
	private double[][] connections;

	// index of prosumer in array is also the index of row and column in matrix
	// which is stored as id in prosumer
	private ArrayList<Prosumer> prosumers;

	/**
	 * a map between house number and id. house number is given as a input when add
	 * a prosumer. id is generated by program automatically.
	 */
	private HashMap<Integer, Integer> houseNumber_id;

	// electric utility is located at one of prosumer's place which represent by id
	// of that prosumer
	/**
	 * electric_Utility is represented by id of one prosumer, which sell/buy energy
	 * to/from prosumer
	 */
	private int electric_Utility;
	private double price_Electric_Utility;

	/** provide information of weather */
	private WeatherDatabase weather_database;

	// in V
	private double voltage;

	private double time_interval;

	private int remaining_day;

	private TopologyJsonParser parser;

	// extra/needed energy for all prosumers at one hour
	// +/- number means sell/buy
	private double[] prosumers_energy;
	private double[] prosumers_price;
	
	private ArrayList<Integer> sellers;
	private ArrayList<Integer> buyers;

	private PlanBalanceCostEnergyLoss plan;
	
	/**
	 * Build a topology which prosumers are nodes, and connections between two
	 * prosumers are links
	 * 
	 * @param prosumer_info
	 *            path of a file that contain information of all prosumers
	 * @param relation_info
	 *            path of a file that contain resistance, max load information among
	 *            all prosumers
	 */
	public NodeNetwork(String prosumer_info, String relation_info) {

		this.parser = new TopologyJsonParser(this, prosumer_info, relation_info);

		this.prosumers = new ArrayList<Prosumer>();
		this.houseNumber_id = new HashMap<Integer, Integer>();
		this.voltage = 220;
		this.time_interval = 1;
		this.plan = new PlanBalanceCostEnergyLoss( this );
		
		parser.parseProsumers();
		initialMatrix();
		parser.parseRelations();

	}

	public NodeNetwork(String prosumer_info, String relation_info, String weather_info) {

		this(prosumer_info, relation_info);

		weather_database = new WeatherDatabase(weather_info);

	}

	public NodeNetwork(String prosumer_info, String relation_info, String weather_info, int remaining_day) {

		this(prosumer_info, relation_info, weather_info);

		this.remaining_day = remaining_day;

	}

	/**
	 * Initial the matrix that use for store information of connection, max load,
	 * and energy flow
	 */
	private void initialMatrix() {

		this.loads_status = new double[prosumers.size()][prosumers.size()];
		this.max_loads = new double[prosumers.size()][prosumers.size()];
		this.connections = new double[prosumers.size()][prosumers.size()];
		this.prosumers_energy = new double[prosumers.size()];

		int nProsumer = this.prosumers.size();

		for (int i = 0; i < nProsumer; i++) {
			for (int j = 0; j < nProsumer; j++) {
				this.loads_status[i][j] = 0;
				this.max_loads[i][j] = -1;
				this.connections[i][j] = -1;
			}
		}

	}

	public void hashHouseId(int houseNumber, int prosumer_ID) {
		this.houseNumber_id.put(houseNumber, prosumer_ID);
	}

	public void addProsumer(Prosumer prosumer) {
		this.prosumers.add(prosumer);
	}

	public int getId(int houseNumber) {
		return this.houseNumber_id.get(houseNumber);
	}

	public void addConnection(int houseA, int houseB, double maxLoad, double resistance) {

		this.max_loads[houseA][houseB] = maxLoad;
		this.max_loads[houseB][houseA] = maxLoad;
		this.connections[houseA][houseB] = resistance;
		this.connections[houseB][houseA] = resistance;

	}

	public void setElectricUtility(int houseNumber) {
		this.electric_Utility = this.houseNumber_id.get(houseNumber);
	}

	/**
	 * print all information(house number, wind turbines, photovoltaic panels) of
	 * prosumers, and their relationship
	 */
	public void printNodeInfo() {
		for (Prosumer prosumer : this.prosumers) {
			System.out.println(prosumer.info());
		}
		int n = prosumers.size();
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < i; j++) {
				if (this.connections[i][j] >= 0) {
					System.out.println("Connection between " + prosumers.get(i).getHouseNumber() + " and "
							+ prosumers.get(j).getHouseNumber() + ": " + this.connections[i][j] + "R, "
							+ this.max_loads[i][j] + "J");
				}
			}
		}
	}

	private void printMatrix(double[][] matrix) {

		int n = this.prosumers.size();
		String line;
		String number = "";

		int digits = 0;
		while (n != 0) {
			digits++;
			n = n / 10;
		}

		if (digits == 0) {
			System.out.println("Error: no valid prosumer");
		}

		if (digits > 3) {
			System.out.println("Information: too much prosumers");
		}

		// System.out.println( this.prosumers.size() );

		// first index row
		line = "   ";
		for (int i = 0; i < this.prosumers.size(); i++) {
			if (i < 10) {
				line = line + "    " + i;
			} else {
				line = line + "   " + i;
			}
		}
		System.out.println(line);

		// print the matrix
		for (int i = 0; i < this.prosumers.size(); i++) {
			// add index column
			if (i < 10) {
				line = " " + i + " ";
			} else {
				line = "" + i + " ";
			}
			// add matrix value with fix size (max 4 digit)
			for (int j = 0; j < this.prosumers.size(); j++) {
				number = "" + matrix[i][j];

				if (number.length() > 5) {
					number = number.substring(0, 4);
				}
				while (number.length() < 5) {
					number = " " + number;
				}

				// add matrix value
				line = line + number;
			}

			System.out.println(line);
		}
	}

	public void printMaxLoad() {
		System.out.println("Max Load");
		printMatrix(this.max_loads);
	}

	public void printConnection() {
		System.out.println("Connection");
		printMatrix(this.connections);
	}

	public void printLoadsStatus() {
		System.out.println("Energy flows");
		printMatrix(this.loads_status);
	}

	private void simulation_hour(Weather weather, int hour) {
		// simulate weather -> renewable energy production -> consumption for each
		// prosumer -> optimising the energy flow

		// covert unit from 0.1m/s to 1m/s
		double wind_speed = weather.windSpeed() / 10;

		// covert unit from J/cm^2 per day to J/m^2 per hour
		double solar_radiation = weather.solarRadiation(hour) * 10000 / 24;

		double air_density = weather.airDensity();

		// test
		System.out.println(
				weather.date() + " at " + hour + " wind speed: " + wind_speed + " solar radiation: " + solar_radiation);
		for (Prosumer p : prosumers) {
			System.out.println("Prosumer " + p.getID() + " output: "
					+ p.powerOutput(weather.airDensity(), wind_speed, solar_radiation) + " Watt(J/s)" + " consumption: "
					+ p.energyConsume(hour) + " Wh(J)");
		}

		// put net energy for each prosumer into prosumers_energy array
		int index;
		for (Prosumer p : this.prosumers) {
			index = p.getID();
			this.prosumers_energy[index] = p.output(air_density, wind_speed, solar_radiation, hour);
		}

		this.buyers = getBuyers();

		// maybe sort the buyers from far to close by distance to electric utility
		
		
		// for each buyer find energy sellers ( prosumer or electric utility )
		for (int i : buyers) {
			// simulate the energy flow
			// this.plan.prosumerCost( )
			
		}

		// clear matrix for current status for next simulation

	}

	public void simulation_day() {
		int hour = 0;
		Weather weather = this.weather_database.nextWeather();
		weather.info();

		for (; hour < 24; hour++) {
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			// simulate the consume and produce per hour
			simulation_hour(weather, hour);
		}
	}

	@Override
	public void run() {

		while (this.remaining_day > 0) {
			this.remaining_day--;
			// simulate the consume and produce per day
			simulation_day();
		}

	}

	public ArrayList<Integer> getSellers() {
		ArrayList<Integer> sellers = new ArrayList<Integer>();
		for (int i = 0; i < this.prosumers_energy.length; i++) {
			if (this.prosumers_energy[i] > 0) {
				sellers.add(i);
			}
		}
		return sellers;
	}
	
	public ArrayList<Integer> getNeighbours(int house_id) {
		ArrayList<Integer> neighbours = new ArrayList<Integer>();
		int n = this.prosumers.size();
		for (int i = 0; i < n; i++) {
			// three assumption to check the neighbours
			// 1. there is connection between house_id and i
			// 2. there is no energy flow form i to house_id
			// 3. the energy flow from house_id to i is smaller than the max load between
			// them
			if (this.connections[house_id][i] >= 0 && this.loads_status[i][house_id] == 0
					&& this.loads_status[house_id][i] < this.max_loads[house_id][i]) {
				neighbours.add(i);
			}
		}
		return neighbours;
	}

	public ArrayList<Integer> getBuyers() {
		ArrayList<Integer> buyers = new ArrayList<Integer>();
		for (int i = 0; i < this.prosumers_energy.length; i++) {
			if (this.prosumers_energy[i] < 0) {
				buyers.add(i);
			}
		}
		return buyers;
	}

	public double[] getResistances(int source) {
		int n = this.prosumers.size();
		double[] connection = new double[n];
		for (int i = 0; i < n; i++) {
			connection[i] = this.connections[source][i];
		}
		return connection;
	}

	public double getResistance(int i, int j) {
		if (i < 0 || i < this.prosumers.size() || j < 0 || j < this.prosumers.size()) {
			System.out.println("Error: Invalid house id");
			return -1;
		}
		return this.connections[i][j];
	}

	public int getNumberOfProsumers() {
		return this.prosumers.size();
	}

	public double getVoltage() {
		return this.voltage;
	}

	public double getTimeInterval() {
		return this.time_interval;
	}

	public double getCapacity(ArrayList<Integer> path) {

		double min_capacity = Double.MAX_VALUE;

		int prosumerA = path.get(0);
		path.remove(0);

		int prosumerB;

		while (!path.isEmpty()) {
			prosumerB = path.get(0);
			path.remove(0);

			if (this.loads_status[prosumerB][prosumerA] == 0) {
				double capacityAB = this.max_loads[prosumerA][prosumerB] - this.loads_status[prosumerA][prosumerB];
				if (capacityAB < min_capacity) {
					min_capacity = capacityAB;
				}
			}

			prosumerA = prosumerB;
		}
		return min_capacity;

	}

	public double getResistance(ArrayList<Integer> path) {

		double resistance = 0;

		int prosumerA = path.get(0);
		path.remove(0);

		int prosumerB;

		while (!path.isEmpty()) {
			prosumerB = path.get(0);
			path.remove(0);

			resistance = resistance + getResistance(prosumerA, prosumerB);

			prosumerA = prosumerB;
		}
		return resistance;

	}

	public void updateCapacity(ArrayList<Integer> path, double rest) {
		int prosumerA = path.get(0);
		path.remove(0);

		int prosumerB;

		while (!path.isEmpty()) {
			prosumerB = path.get(0);
			path.remove(0);

			this.loads_status[prosumerA][prosumerB] = this.loads_status[prosumerA][prosumerB] + rest; 
			
			prosumerA = prosumerB;
		}
	}

	public double getCurrentEnergy(int provider) {
		return this.prosumers_energy[provider];
	}

	public double getCurrentPrice(int provider) {
		// return the price of enegry for the provider
		return 0.8;
	}

	public double getPriceEC() {
		return 1;
	}

	public int getElecticUtility() {
		return this.electric_Utility;
	}

	public double calculateEnergyLoss(int electicUtility, int consumer, double energy) {
		// energy loss from electric utility to consumer when transfer energy
		return 0;
	}

	public void transferEnergy(double[] energy_sell) {
		for( int i = 0; i < this.prosumers_energy.length; i++ ) {
			this.prosumers_energy[i] = this.prosumers_energy[i] - energy_sell[i];
		}
	}
	
	

}
